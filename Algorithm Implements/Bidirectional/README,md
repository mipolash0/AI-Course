ğŸ” Bidirectional Search in C++
ğŸ“– Overview
Bidirectional Search is an efficient graph search technique that simultaneously performs two BFS traversals â€” one from the start node and the other from the goal node. The search stops once both traversals meet at a common node (the intersection point), significantly reducing search time from O(b^d) to O(b^(d/2)), where b is the branching factor and d is the distance to the goal.

ğŸ“Œ Key Features
âœ… Interactive CLI for node count, edge list, start, and goal nodes

âœ… Works on undirected graphs

âœ… Implements dual BFS using queue and unordered_set

âœ… Detects intersection point efficiently

âœ… Lightweight and portable C++17 implementation

ğŸ”§ How the Algorithm Works
Initialize:

forward_queue starting from start

backward_queue starting from goal

visited_forward and visited_backward sets

Alternately expand nodes from both queues using BFS.

After each expansion:

Check if any node appears in both visited sets

If yes â†’ Meeting point found, path exists

If no intersection and both queues are empty â†’ No path

âš ï¸ Assumes undirected graph for symmetric traversal.

ğŸ–¥ Sample Input / Output
âœ… Input:
yaml
Copy
Edit
Enter number of nodes and edges: 6 7
Enter edges:
0 1
0 2
1 3
2 4
3 5
4 5
2 5
Enter start and goal: 0 5
ğŸ”½ Output:
pgsql
Copy
Edit
Path found (meeting point at node: 5)
ğŸŒ Graph Representation
plaintext
Copy
Edit
      0
     / \
    1   2
    |  / \
    3 4   5
     \____/
Possible paths from 0 to 5:

0 â†’ 2 â†’ 5

0 â†’ 1 â†’ 3 â†’ 5

0 â†’ 2 â†’ 4 â†’ 5

ğŸš€ Applications
Domain	Use Case Example
ğŸŒ Social Networks	Shortest connection between two users
ğŸ›£ Routing Systems	Quick road/path search between locations
ğŸ•¹ Game AI	Symmetric pathfinding in maze or grid games
ğŸ” Web Crawling	Reverse path lookup between two pages
ğŸ—ƒ Databases	Relationship tracing in graph DBs (e.g., Neo4j)
